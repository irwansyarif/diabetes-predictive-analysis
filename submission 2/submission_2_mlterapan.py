# -*- coding: utf-8 -*-
"""Submission 2 MLTerapan

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1osCv1FnqOewbb3-LHbaqwbPW0EPOWqnD

# Recommendation System - Merekomendasikan Judul Anime Berdasarkan Genrenya

### Deskripsi Proyek
Dalam upaya menghadapi persaingan yang semakin ketat di industri anime, sebuah perusahaan penyedia layanan streaming khusus anime berencana meningkatkan traffic dan retensi pengguna di platform mereka. Salah satu strategi yang diambil adalah dengan memanfaatkan teknologi Machine Learning untuk membangun sistem rekomendasi film yang lebih personal. Sistem ini akan menganalisis preferensi pengguna berdasarkan genre anime yang sering ditonton, lalu menyarankan judul-judul anime yang relevan dan menarik. Pendekatan ini diharapkan tidak hanya meningkatkan kepuasan pengguna, tetapi juga memperkuat posisi perusahaan di pasar industri anime yang terus berkembang.

## Import Library
"""

import os
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
import numpy as np
from zipfile import ZipFile
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import layers
from pathlib import Path
import matplotlib.pyplot as plt
from sklearn.neighbors import NearestNeighbors

"""## Download Dataset"""

!mkdir ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!kaggle datasets download -d quanthan/top-15000-ranked-anime-dataset-update-to-32025

!unzip top-15000-ranked-anime-dataset-update-to-32025.zip

"""# Data Understanding"""

import pandas as pd

anime = pd.read_csv('/content/top_anime_dataset.csv')

print('Jumlah data judul anime: ', len(anime.anime_id.unique()))
print('Jumlah data ratings score: ', len(anime.score.unique()))

"""## Univariate Exploratory Data (EDA)

Exploratory data analysis merupakan proses investigasi awal pada data untuk menganalisis karakteristik, menemukan pola, anomali, dan memeriksa asumsi pada data. Teknik ini biasanya menggunakan bantuan statistik dan representasi grafis atau visualisasi.
"""

anime.info()

anime.head()

# prompt: make a code to visualisasi fitur numerik

# Visualisasi fitur numerik (contoh: score)
plt.figure(figsize=(8, 6))
plt.hist(anime['score'].dropna(), bins=20, color='skyblue', edgecolor='black')
plt.title('Distribusi Score Anime')
plt.xlabel('Score')
plt.ylabel('Jumlah Anime')
plt.show()

# visualisasi fitur numerik yang ada di dataset rating
anime.hist(bins=50, figsize=(20,15))
plt.show()

""" Menampilkan Jumlah Nilai Kosong (NaN) di Setiap Kolom dari DataFrame anime."""

anime.isnull().sum()

"""Terdapat data yang duplikat pada kolom english_name, japanese_names, genres, sypnosis, type, episodes, premiered, producers, studios, rank"""

print(f'Jumlah data anime yang duplikat: {anime.duplicated().sum()}')

"""Menjadikan dataset hanya memiliki kolom anime_id, genres, score, type, dan studios"""

# Keep only the desired columns
columns_to_keep = ['anime_id', 'name', 'genres', 'score', 'type', 'studios']
anime = anime[columns_to_keep]

# Display the first few rows of the filtered DataFrame
print(anime.head())

"""# Data preparation"""

anime.head()

"""### Splitting data genre from dataset

Membagi dataset berdasarkan genre
"""

animes_new = anime.assign(genres=anime.genres.str.split('|')).explode('genres').reset_index(drop=True)
animes_new

"""### Menangani missing value

Menampilkan jumlah nilai yang hilang (NaN) di setiap kolom dari DataFrame animes_new.
"""

animes_new.isnull().sum()

"""Menghapus semua baris yang mengandung nilai kosong (NaN) dari DataFrame animes_new, dan menyimpannya ke variabel animes."""

# Membuang data yang kosong
animes = animes_new.dropna()
animes

"""Menyortir DataFrame animes berdasarkan kolom anime_id secara menaik (dari angka kecil ke besar).


"""

# Menampilkan data dan mengurutkannya berdasarkan movieId
animes = animes.sort_values('anime_id', ascending=True)
animes

len(animes.anime_id.unique())

print('Genres: ', animes.genres.unique())

"""### Menghapus data duplikat"""

# Menghapus data duplikat pada variabel preparation
animes = animes.drop_duplicates('anime_id')
animes

"""#### Mengonversi data series anime_id,name, dan genres menjadi bentuk list

"""

# Mengonversi data series ‘anime_id’ menjadi bentuk list
anime_id = animes['anime_id'].tolist()

# Mengonversi data series 'name' menjadi bentuk list
anime_title = animes['name'].tolist()

# Mengonversi data series ‘genres’ menjadi bentuk list
anime_genre = animes['genres'].tolist()

print(len(anime_id))
print(len(anime_title))
print(len(anime_genre))

"""# Model Development dengan Content Based Filtering

Content-Based Filtering adalah metode rekomendasi yang menggunakan informasi atau fitur dari item (seperti deskripsi, genre, atau atribut lainnya) untuk merekomendasikan item serupa.

### TF-IDF Vectorizer

Salah satu pendekatan populer adalah menggunakan TF-IDF (Term Frequency-Inverse Document Frequency) Vectorizer, yang mengubah teks (misalnya, sinopsis film atau deskripsi produk) menjadi representasi numerik berdasarkan seberapa penting kata tersebut dalam dokumen tertentu dibandingkan seluruh koleksi.
"""

# Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# Melakukan perhitungan idf pada data genre
tf.fit(animes['genres'])

# Mapping array dari fitur index integer ke fitur nama
tf.get_feature_names_out()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(animes['genres'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=animes.genres
).sample(12, axis=1).sample(10, axis=0)

"""##Cosine Similiarity

Cosine Similarity adalah ukuran kemiripan antara dua vektor dalam ruang vektor berdimensi tinggi. Nilainya berkisar dari -1 hingga 1, tetapi dalam konteks TF-IDF dan rekomendasi, nilainya biasanya antara 0 dan 1, karena semua nilai dalam vektor TF-IDF adalah non-negatif.
"""

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama anime
cosine_sim_df = pd.DataFrame(cosine_sim, index=animes['name'], columns=animes['name'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap nama anime
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

"""#Pengujian Anime Recommendation"""

def anime_recommendations(title, similarity_data=cosine_sim_df, items=animes[['name', 'genres']], k=10):
    # Mengambil data dengan menggunakan argpartition untuk melakukan partisi secara tidak langsung sepanjang sumbu yang diberikan
    # Dataframe diubah menjadi numpy
    # Range(start, stop, step)
    index = similarity_data.loc[:,title].to_numpy().argpartition(
        range(-1, -k, -1))

    # Mengambil data dengan similarity terbesar dari index yang ada
    closest = similarity_data.columns[index[-1:-(k+2):-1]]

    # Membuang movie_title agar nama film yang dicari tidak muncul dalam daftar rekomendasi
    closest = closest.drop(title, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

"""## Result"""

# Melihat genre film yang akan diuji
anime_title = 'Sousou no Frieren'
animes[animes.name.eq(anime_title)]

anime_recommendations = anime_recommendations(anime_title)
anime_recommendations

"""# Evaluation

### Metrik yang cocok dipakai untuk kasus content based filtering adalah Precision.
"""

relevant_genres = {"Adventure", "Drama", "Fantasy"}  # gunakan set agar urutan tidak penting

# Fungsi untuk memeriksa kecocokan genre
def is_relevant(genres):
    genres_set = set(genres.split(', '))  # ubah string genre menjadi set
    return relevant_genres.issubset(genres_set)  # periksa apakah semua genre relevan ada dalam genres_set

# Tambahkan kolom apakah film relevan
anime_recommendations['is_relevant'] = anime_recommendations['genres'].apply(is_relevant)

# Hitung True Positives dan Total Recommended
true_positives = anime_recommendations['is_relevant'].sum()
total_recommended = len(anime_recommendations)

# Precision
precision = true_positives / total_recommended * 100
print(f"Precision: {precision:.2f}%")

"""Dari hasil diatas, nilai metriks precesion sebesar 100.00% untuk 10 anime yang direkomendasikan berdasarkan kemiripan genre."""